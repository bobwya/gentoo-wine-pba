From 11856ca314d7be92c74d50a0c7de8067b4996d36 Mon Sep 17 00:00:00 2001
From: Andrew Comminos <andrew@comminos.com>
Date: Thu, 8 Mar 2018 23:01:50 -0800
Subject: [PATCH 07/11] wined3d: Avoid freeing persistent buffer heap elements
 during use.

Using HeapFree is expensive, especially when we don't have our buffers
for long.

Signed-off-by: Rob Walker <bob.mt.wya@gmail.com>
---
 dlls/wined3d/buffer.c          | 29 +++++++++--------
 dlls/wined3d/buffer_heap.c     | 57 ++++++++++++++--------------------
 dlls/wined3d/context.c         |  4 +--
 dlls/wined3d/cs.c              |  6 ++--
 dlls/wined3d/wined3d_private.h | 25 ++++++++++-----
 5 files changed, 61 insertions(+), 60 deletions(-)

diff --git a/dlls/wined3d/buffer.c b/dlls/wined3d/buffer.c
index d038885cc1d..5e3df085a19 100644
--- a/dlls/wined3d/buffer.c
+++ b/dlls/wined3d/buffer.c
@@ -281,3 +281,3 @@ static BOOL buffer_alloc_persistent_map(struct wined3d_buffer *buffer)
     struct wined3d_buffer_heap *heap;
-    struct wined3d_map_range map_range;
+    struct wined3d_buffer_heap_element *elem;
     HRESULT hr;
@@ -297,3 +297,3 @@ static BOOL buffer_alloc_persistent_map(struct wined3d_buffer *buffer)
     buffer->buffer_heap = heap;
-    if (FAILED(hr = wined3d_buffer_heap_alloc(heap, resource->size, &map_range)))
+    if (FAILED(hr = wined3d_buffer_heap_alloc(heap, resource->size, &elem)))
     {
@@ -301,4 +301,4 @@ static BOOL buffer_alloc_persistent_map(struct wined3d_buffer *buffer)
     }
-    buffer->cs_persistent_map = map_range;
-    buffer->mt_persistent_map = map_range;
+    buffer->cs_persistent_map = elem;
+    buffer->mt_persistent_map = elem;
     return TRUE;
@@ -758,3 +758,3 @@ BOOL wined3d_buffer_load_location(struct wined3d_buffer *buffer,
             memcpy(buffer->buffer_heap->map_ptr +
-                   buffer->cs_persistent_map.offset,
+                   buffer->cs_persistent_map->range.offset,
                    buffer->resource.heap_memory, buffer->resource.size);
@@ -806,3 +806,3 @@ DWORD wined3d_buffer_get_memory(struct wined3d_buffer *buffer,
         data->buffer_object = buffer->buffer_heap->buffer_object;
-        data->addr = buffer->cs_persistent_map.offset;
+        data->addr = buffer->cs_persistent_map->range.offset;
         // Note that the size of the underlying buffer allocation may be larger
@@ -810,3 +810,3 @@ DWORD wined3d_buffer_get_memory(struct wined3d_buffer *buffer,
         // aligned (e.g. for uniform buffer offsets).
-        data->length = buffer->cs_persistent_map.size;
+        data->length = buffer->cs_persistent_map->range.size;
         return WINED3D_LOCATION_PERSISTENT_MAP;
@@ -1131,3 +1131,3 @@ static HRESULT wined3d_buffer_gl_map(struct wined3d_buffer_gl *buffer_gl,
         base = buffer_gl->b.buffer_heap->map_ptr
-             + buffer_gl->b.cs_persistent_map.offset;
+             + buffer_gl->b.cs_persistent_map->range.offset;
         *data = base + offset;
@@ -1441,4 +1441,4 @@ static HRESULT buffer_resource_sub_resource_map(struct wined3d_resource *resourc
             HRESULT hr;
-            struct wined3d_map_range map_range;
-            if (FAILED(hr = wined3d_buffer_heap_alloc(buffer->buffer_heap, resource->size, &map_range)))
+            struct wined3d_buffer_heap_element *mt_elem;
+            if (FAILED(hr = wined3d_buffer_heap_alloc(buffer->buffer_heap, resource->size, &mt_elem)))
             {
@@ -1447,6 +1447,6 @@ static HRESULT buffer_resource_sub_resource_map(struct wined3d_resource *resourc
             }
-            map_desc->data = buffer->buffer_heap->map_ptr + map_range.offset + offset;
+            map_desc->data = buffer->buffer_heap->map_ptr + mt_elem->range.offset + offset;
             resource->map_count++;
 
-            buffer->mt_persistent_map = map_range;
+            buffer->mt_persistent_map = mt_elem;
 
@@ -1455,4 +1455,3 @@ static HRESULT buffer_resource_sub_resource_map(struct wined3d_resource *resourc
             // must be called before the buffer can be reused.
-            wined3d_cs_emit_discard_buffer(resource->device->cs, buffer, map_range);
-
+            wined3d_cs_emit_discard_buffer(resource->device->cs, buffer, mt_elem);
             return WINED3D_OK;
@@ -1464,3 +1463,3 @@ static HRESULT buffer_resource_sub_resource_map(struct wined3d_resource *resourc
             // DISCARDed one hasn't reached the command stream yet.
-            struct wined3d_map_range map_range = buffer->mt_persistent_map;
+            struct wined3d_map_range map_range = buffer->mt_persistent_map->range;
             map_desc->data = buffer->buffer_heap->map_ptr + map_range.offset + offset;
diff --git a/dlls/wined3d/buffer_heap.c b/dlls/wined3d/buffer_heap.c
index 75f84b00882..80670c515f7 100644
--- a/dlls/wined3d/buffer_heap.c
+++ b/dlls/wined3d/buffer_heap.c
@@ -27,14 +27,2 @@ WINE_DECLARE_DEBUG_CHANNEL(d3d_perf);
 
-struct wined3d_buffer_heap_element
-{
-    struct wined3d_map_range range;
-
-    // rbtree data
-    struct wine_rb_entry entry;
-
-    // Binned free list positions
-    struct wined3d_buffer_heap_element *next;
-    struct wined3d_buffer_heap_element *prev;
-};
-
 struct wined3d_buffer_heap_fenced_element
@@ -84,2 +72,7 @@ static void element_insert_free_bin(struct wined3d_buffer_heap *heap, struct win
 {
+    if (elem->prev || elem->next)
+    {
+        ERR("Element %p in already in a free list (for some reason).\n", elem);
+    }
+
     int bin = element_bin(elem);
@@ -208,3 +201,3 @@ HRESULT wined3d_buffer_heap_destroy(struct wined3d_buffer_heap *heap, struct win
 
-HRESULT wined3d_buffer_heap_alloc(struct wined3d_buffer_heap *heap, GLsizeiptr size, struct wined3d_map_range *out_range)
+HRESULT wined3d_buffer_heap_alloc(struct wined3d_buffer_heap *heap, GLsizeiptr size, struct wined3d_buffer_heap_element **out_elem)
 {
@@ -235,9 +228,11 @@ HRESULT wined3d_buffer_heap_alloc(struct wined3d_buffer_heap *heap, GLsizeiptr s
 
-            out_range->offset = elem->range.offset;
-            out_range->size = size;
+            // Take the element from the free list, transferring ownership to
+            // the caller.
+            element_remove_free(heap, elem);
+            // Resize the element so that we can free the remainder.
+            elem->range.size = size;
 
-            TRACE_(d3d_perf)("Allocated %d (requested %d) at %p from bin %d (initial %d)\n", size, initial_size, elem->range.offset, i, initial_bin);
+            *out_elem = elem;
 
-            // Remove the element from its current free bin to move it to the correct list.
-            element_remove_free(heap, elem);
+            TRACE_(d3d_perf)("Allocated %d (requested %d) at %p from bin %d (initial %d)\n", size, initial_size, elem->range.offset, i, initial_bin);
 
@@ -245,10 +240,8 @@ HRESULT wined3d_buffer_heap_alloc(struct wined3d_buffer_heap *heap, GLsizeiptr s
             {
+                struct wined3d_buffer_heap_element *remaining_elem;
+
                 TRACE_(d3d_perf)("Imperfect fit allocated, fragmenting remainder of %lld at %p.\n", remaining_range.size, remaining_range.offset);
 
-                elem->range = remaining_range;
-                element_insert_free_bin(heap, elem);
-            }
-            else
-            {
-                HeapFree(GetProcessHeap(), 0, elem);
+                remaining_elem = element_new(remaining_range.offset, remaining_range.size);
+                element_insert_free_bin(heap, remaining_elem);
             }
@@ -267,3 +260,3 @@ HRESULT wined3d_buffer_heap_alloc(struct wined3d_buffer_heap *heap, GLsizeiptr s
         if (num_coalesced > 0)
-            return wined3d_buffer_heap_alloc(heap, size, out_range);
+            return wined3d_buffer_heap_alloc(heap, size, out_elem);
     }
@@ -275,9 +268,4 @@ HRESULT wined3d_buffer_heap_alloc(struct wined3d_buffer_heap *heap, GLsizeiptr s
 
-HRESULT wined3d_buffer_heap_free(struct wined3d_buffer_heap *heap, struct wined3d_map_range range)
+HRESULT wined3d_buffer_heap_free(struct wined3d_buffer_heap *heap, struct wined3d_buffer_heap_element *elem)
 {
-    struct wined3d_buffer_heap_element *elem = element_new(range.offset, range.size);
-
-    if (!elem)
-        return E_OUTOFMEMORY;
-
     EnterCriticalSection(&heap->temp_lock);
@@ -285,2 +273,6 @@ HRESULT wined3d_buffer_heap_free(struct wined3d_buffer_heap *heap, struct wined3
     // Only insert the element into a free bin, coalescing will occur later.
+    //
+    // Note that the reason that we pass around wined3d_buffer_heap_element
+    // instead of a range is to avoid frequent HeapAlloc/HeapFree operations
+    // when we're reusing buffers.
     element_insert_free_bin(heap, elem);
@@ -292,5 +284,4 @@ HRESULT wined3d_buffer_heap_free(struct wined3d_buffer_heap *heap, struct wined3
 
-HRESULT wined3d_buffer_heap_free_fenced(struct wined3d_buffer_heap *heap, struct wined3d_device *device, struct wined3d_map_range range)
+HRESULT wined3d_buffer_heap_free_fenced(struct wined3d_buffer_heap *heap, struct wined3d_device *device, struct wined3d_buffer_heap_element *elem)
 {
-    struct wined3d_buffer_heap_element *elem = element_new(range.offset, range.size);
     int bin_index = element_bin(elem);
diff --git a/dlls/wined3d/context.c b/dlls/wined3d/context.c
index 27f173b4e10..6e1ccf8602f 100644
--- a/dlls/wined3d/context.c
+++ b/dlls/wined3d/context.c
@@ -4905,5 +4905,5 @@ void draw_primitive(struct wined3d_device *device, const struct wined3d_state *s
         struct wined3d_buffer *index_buffer = state->index_buffer;
-        if (index_buffer->locations & WINED3D_LOCATION_PERSISTENT_MAP)
+        if (index_buffer->cs_persistent_map)
         {
-            idx_data = index_buffer->cs_persistent_map.offset;
+            idx_data = index_buffer->cs_persistent_map->range.offset;
         }
diff --git a/dlls/wined3d/cs.c b/dlls/wined3d/cs.c
index 0f5dd607c95..f79ad0d2aae 100644
--- a/dlls/wined3d/cs.c
+++ b/dlls/wined3d/cs.c
@@ -446,3 +446,3 @@ struct wined3d_cs_discard_buffer
     struct wined3d_buffer *buffer;
-    struct wined3d_map_range map_range;
+    struct wined3d_buffer_heap_element *map_range;
 };
@@ -2530,3 +2530,3 @@ static void wined3d_cs_exec_discard_buffer(struct wined3d_cs *cs, const void *da
 
-void wined3d_cs_emit_discard_buffer(struct wined3d_cs *cs, struct wined3d_buffer *buffer, struct wined3d_map_range map_range)
+void wined3d_cs_emit_discard_buffer(struct wined3d_cs *cs, struct wined3d_buffer *buffer, struct wined3d_buffer_heap_element *elem)
 {
@@ -2537,3 +2537,3 @@ void wined3d_cs_emit_discard_buffer(struct wined3d_cs *cs, struct wined3d_buffer
     op->buffer = buffer;
-    op->map_range = map_range;
+    op->map_range = elem;
 
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
index 2cf735e1486..9eec2ed94e4 100644
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -3601,2 +3601,14 @@ struct wined3d_map_range
 
+struct wined3d_buffer_heap_element
+{
+    struct wined3d_map_range range;
+
+    // rbtree data
+    struct wine_rb_entry entry;
+
+    // Binned free list positions
+    struct wined3d_buffer_heap_element *next;
+    struct wined3d_buffer_heap_element *prev;
+};
+
 enum wined3d_cs_queue_id
@@ -3745,3 +3757,3 @@ void wined3d_cs_emit_update_sub_resource(struct wined3d_cs *cs, struct wined3d_r
         unsigned int slice_pitch) DECLSPEC_HIDDEN;
-void wined3d_cs_emit_discard_buffer(struct wined3d_cs *cs, struct wined3d_buffer *buffer, struct wined3d_map_range map_range) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_discard_buffer(struct wined3d_cs *cs, struct wined3d_buffer *buffer, struct wined3d_buffer_heap_element *map_range) DECLSPEC_HIDDEN;
 void wined3d_cs_init_object(struct wined3d_cs *cs,
@@ -3779,3 +3791,2 @@ enum wined3d_buffer_conversion_type
 
-struct wined3d_buffer_heap_element;
 struct wined3d_buffer_heap_fenced_element;
@@ -3818,7 +3829,7 @@ HRESULT wined3d_buffer_heap_destroy(struct wined3d_buffer_heap *heap, struct win
 // Attempts to coalesce blocks under memory pressure.
-HRESULT wined3d_buffer_heap_alloc(struct wined3d_buffer_heap *heap, GLsizeiptr size, struct wined3d_map_range* out_range) DECLSPEC_HIDDEN;
+HRESULT wined3d_buffer_heap_alloc(struct wined3d_buffer_heap *heap, GLsizeiptr size, struct wined3d_buffer_heap_element** out_elem) DECLSPEC_HIDDEN;
 // Immediately frees a heap-allocated buffer segment.
-HRESULT wined3d_buffer_heap_free(struct wined3d_buffer_heap *heap, struct wined3d_map_range range) DECLSPEC_HIDDEN;
+HRESULT wined3d_buffer_heap_free(struct wined3d_buffer_heap *heap, struct wined3d_buffer_heap_element *elem) DECLSPEC_HIDDEN;
 // Enqueues a buffer segment to return to the heap once its fence has been signaled.
-HRESULT wined3d_buffer_heap_free_fenced(struct wined3d_buffer_heap *heap, struct wined3d_device *device, struct wined3d_map_range range) DECLSPEC_HIDDEN;
+HRESULT wined3d_buffer_heap_free_fenced(struct wined3d_buffer_heap *heap, struct wined3d_device *device, struct wined3d_buffer_heap_element *elem) DECLSPEC_HIDDEN;
 // Issues a fence for the current set of pending fenced buffers.
@@ -3858,4 +3869,4 @@ struct wined3d_buffer
     struct wined3d_buffer_heap *buffer_heap;
-    struct wined3d_map_range cs_persistent_map;
-    struct wined3d_map_range mt_persistent_map; // TODO: make struct list?
+    struct wined3d_buffer_heap_element *cs_persistent_map;
+    struct wined3d_buffer_heap_element *mt_persistent_map;
 };
-- 
2.19.1

