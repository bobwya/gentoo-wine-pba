From b78ccde081f46f02dd93bee7f6d54c861fe6cd4f Mon Sep 17 00:00:00 2001
From: Andrew Comminos <andrew@comminos.com>
Date: Thu, 8 Mar 2018 22:42:03 -0800
Subject: [PATCH 06/11] wined3d: Perform initial allocation of persistent
 buffers asynchronously.

Signed-off-by: Rob Walker <bob.mt.wya@gmail.com>
---
 dlls/wined3d/buffer.c | 30 ++++++++++++++++++++----------
 1 file changed, 20 insertions(+), 10 deletions(-)

diff --git a/dlls/wined3d/buffer.c b/dlls/wined3d/buffer.c
index 05f40a6e9d..edc4fb8e8e 100644
--- a/dlls/wined3d/buffer.c
+++ b/dlls/wined3d/buffer.c
@@ -272,5 +272,5 @@ fail:
 }
 
 /* Context activation is done by the caller. */
-static BOOL buffer_alloc_persistent_map(struct wined3d_buffer *buffer, struct wined3d_context *context)
+static BOOL buffer_alloc_persistent_map(struct wined3d_buffer *buffer)
 {
@@ -685,7 +685,7 @@ static BOOL wined3d_buffer_prepare_location(struct wined3d_buffer *buffer,
                 WARN("Trying to map a persistent region for buffer %p without WINED3D_BUFFER_PERSISTENT.\n", buffer);
                 return FALSE;
             }
-            return buffer_alloc_persistent_map(buffer, context);
+            return buffer_alloc_persistent_map(buffer);
 
         default:
             ERR("Invalid location %s.\n", wined3d_debug_location(location));
@@ -1113,7 +1113,7 @@ static HRESULT wined3d_buffer_gl_map(struct wined3d_buffer_gl *buffer_gl,
         const struct wined3d_gl_info *gl_info;
         context = context_acquire(device, NULL, 0);
 
-        FIXME_(d3d_perf)("Fences not used for persistent buffer maps on CS thread, using glFinish.\n");
+        FIXME_(d3d_perf)("Fences not used for persistent buffer maps on CS thread, using glFinish (flags: %x)\n", flags);
 
         gl_info = context->gl_info;
         gl_info->gl_ops.gl.p_glFinish();
@@ -1428,5 +1428,17 @@ static HRESULT buffer_resource_sub_resource_map(struct wined3d_resource *resourc
-    if (buffer->locations & WINED3D_LOCATION_PERSISTENT_MAP)
+    if (buffer->flags & WINED3D_BUFFER_PERSISTENT)
     {
+        // Attempt to load a persistent map without syncing, if possible.
+        if (!(buffer->locations & WINED3D_LOCATION_PERSISTENT_MAP))
+        {
+            wined3d_resource_wait_idle(resource);
+            if (!buffer_alloc_persistent_map(buffer))
+            {
+                ERR_(d3d_perf)("Failed to allocate persistent buffer, falling back to sync path.");
+                return E_FAIL;
+            }
+            wined3d_buffer_validate_location(buffer, WINED3D_LOCATION_PERSISTENT_MAP);
+        }
+
         map_desc->row_pitch = map_desc->slice_pitch = desc->byte_width;
         if (flags & WINED3D_MAP_DISCARD)
         {
@@ -1458,10 +1458,6 @@ static HRESULT buffer_resource_sub_resource_map(struct wined3d_resource *resourc
             resource->map_count++;
             return WINED3D_OK;
         }
-        else
-        {
-            // TODO(acomminos): Should check mapped ranges to see if the region is writeable even though NOOVERWRITE is specified.
-            WARN_(d3d_perf)("Mapping persistent buffer %p in sync with CS thread.\n", buffer);
-            // XXX(acomminos): kill this early return. they're the worst.
-        }
+
+        WARN_(d3d_perf)("Mapping persistent buffer %p in sync with CS thread.\n", buffer);
     }
-- 
2.19.1

