From ab175aade464256f11a52cd98eae163af3cffee3 Mon Sep 17 00:00:00 2001
From: Andrew Comminos <andrew@comminos.com>
Date: Thu, 8 Mar 2018 22:42:03 -0800
Subject: [PATCH 06/11] wined3d: Perform initial allocation of persistent
 buffers asynchronously.

Signed-off-by: Rob Walker <bob.mt.wya@gmail.com>
---
 dlls/wined3d/buffer.c | 30 ++++++++++++++++++++----------
 1 file changed, 20 insertions(+), 10 deletions(-)

diff --git a/dlls/wined3d/buffer.c b/dlls/wined3d/buffer.c
index 7d83c943464..d038885cc1d 100644
--- a/dlls/wined3d/buffer.c
+++ b/dlls/wined3d/buffer.c
@@ -277,3 +277,3 @@ fail:
 /* Context activation is done by the caller. */
-static BOOL buffer_alloc_persistent_map(struct wined3d_buffer *buffer, struct wined3d_context *context)
+static BOOL buffer_alloc_persistent_map(struct wined3d_buffer *buffer)
 {
@@ -692,3 +692,3 @@ static BOOL wined3d_buffer_prepare_location(struct wined3d_buffer *buffer,
             }
-            return buffer_alloc_persistent_map(buffer, context);
+            return buffer_alloc_persistent_map(buffer);
 
@@ -1125,3 +1125,3 @@ static HRESULT wined3d_buffer_gl_map(struct wined3d_buffer_gl *buffer_gl,
 
-        FIXME_(d3d_perf)("Fences not used for persistent buffer maps on CS thread, using glFinish.\n");
+        FIXME_(d3d_perf)("Fences not used for persistent buffer maps on CS thread, using glFinish (flags: %x)\n", flags);
 
@@ -1423,4 +1423,16 @@ static HRESULT buffer_resource_sub_resource_map(struct wined3d_resource *resourc
     // which require no GL calls to interface with.
-    if (buffer->locations & WINED3D_LOCATION_PERSISTENT_MAP)
+    if (flags & WINED3D_BUFFER_PERSISTENT)
     {
+        // Attempt to load a persistent map without syncing, if possible.
+        if (!(buffer->locations & WINED3D_LOCATION_PERSISTENT_MAP))
+        {
+            wined3d_resource_wait_idle(resource);
+            if (!buffer_alloc_persistent_map(buffer))
+            {
+                ERR_(d3d_perf)("Failed to allocate persistent buffer, falling back to sync path.");
+                return E_FAIL;
+            }
+            wined3d_buffer_validate_location(buffer, WINED3D_LOCATION_PERSISTENT_MAP);
+        }
+
         map_desc->row_pitch = map_desc->slice_pitch = resource->size;
@@ -1444,2 +1456,3 @@ static HRESULT buffer_resource_sub_resource_map(struct wined3d_resource *resourc
             wined3d_cs_emit_discard_buffer(resource->device->cs, buffer, map_range);
+
             return WINED3D_OK;
@@ -1454,10 +1467,7 @@ static HRESULT buffer_resource_sub_resource_map(struct wined3d_resource *resourc
             resource->map_count++;
+
             return WINED3D_OK;
         }
-        else
-        {
-            // TODO(acomminos): Should check mapped ranges to see if the region is writeable even though NOOVERWRITE is specified.
-            WARN_(d3d_perf)("Mapping persistent buffer %p in sync with CS thread.\n", buffer);
-            // XXX(acomminos): kill this early return. they're the worst.
-        }
+
+        WARN_(d3d_perf)("Mapping persistent buffer %p in sync with CS thread.\n", buffer);
     }
-- 
2.19.1

