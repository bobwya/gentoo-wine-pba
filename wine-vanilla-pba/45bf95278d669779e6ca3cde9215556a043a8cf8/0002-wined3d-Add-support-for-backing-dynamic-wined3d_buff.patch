From 147481495d9dee2df168bbe089b1edc9259bfa72 Mon Sep 17 00:00:00 2001
From: Andrew Comminos <andrew@comminos.com>
Date: Mon, 5 Mar 2018 15:39:11 -0800
Subject: [PATCH 02/11] wined3d: Add support for backing dynamic wined3d_buffer
 objects by a persistent map.

Signed-off-by: Rob Walker <bob.mt.wya@gmail.com>
---
 dlls/wined3d/buffer.c          | 221 ++++++++++++++++++++++++++++++++-
 dlls/wined3d/context.c         |   6 +-
 dlls/wined3d/cs.c              |  60 ++++++++-
 dlls/wined3d/resource.c        |  18 ++-
 dlls/wined3d/state.c           |  18 ++-
 dlls/wined3d/texture.c         |  13 ++
 dlls/wined3d/utils.c           |   1 +
 dlls/wined3d/wined3d_private.h |  11 ++
 8 files changed, 337 insertions(+), 11 deletions(-)

diff --git a/dlls/wined3d/buffer.c b/dlls/wined3d/buffer.c
index 58e56857b4c..ef11f0eaa18 100644
--- a/dlls/wined3d/buffer.c
+++ b/dlls/wined3d/buffer.c
@@ -30,2 +30,3 @@
 WINE_DEFAULT_DEBUG_CHANNEL(d3d);
+WINE_DECLARE_DEBUG_CHANNEL(d3d_perf);
 
@@ -36,2 +37,3 @@ WINE_DEFAULT_DEBUG_CHANNEL(d3d);
 #define WINED3D_BUFFER_APPLESYNC    0x10    /* Using sync as in GL_APPLE_flush_buffer_range. */
+#define WINED3D_BUFFER_PERSISTENT   0x20    /* Uses a persistent-mapped buffer via ARB_buffer_storage. */
 
@@ -274,2 +276,49 @@ fail:
 
+/* Context activation is done by the caller. */
+static BOOL buffer_alloc_persistent_map(struct wined3d_buffer *buffer, struct wined3d_context *context)
+{
+    struct wined3d_resource *resource = &buffer->resource;
+    struct wined3d_device *device = resource->device;
+    struct wined3d_buffer_heap *heap;
+    struct wined3d_map_range map_range;
+    HRESULT hr;
+
+    if (resource->bind_flags & WINED3D_BIND_CONSTANT_BUFFER)
+    {
+        // Use a heap aligned to constant buffer offset requirements.
+        heap = device->cb_buffer_heap;
+    }
+    else
+    {
+        if (!(resource->usage & WINED3DUSAGE_WRITEONLY))
+            FIXME("Using a write-only persistent buffer for %p without WINED3DUSAGE_WRITEONLY.\n", buffer);
+        heap = device->wo_buffer_heap;
+    }
+
+    buffer->buffer_heap = heap;
+    if (FAILED(hr = wined3d_buffer_heap_alloc(heap, resource->size, &map_range)))
+    {
+        goto fail;
+    }
+    buffer->cs_persistent_map = map_range;
+    buffer->mt_persistent_map = map_range;
+    return TRUE;
+
+fail:
+    // FIXME(acomminos): fall back to standalone BO here?
+    ERR("Failed to create persistent map for buffer %p, hr=%x\n", buffer, hr);
+    buffer->buffer_heap = NULL;
+    return FALSE;
+}
+
+static void buffer_free_persistent_map(struct wined3d_buffer *buffer)
+{
+    if (!buffer->buffer_heap)
+        return;
+
+    // TODO(acomminos): get the CS thread to free pending main thread buffers.
+    wined3d_buffer_heap_free(buffer->buffer_heap, buffer->cs_persistent_map);
+    buffer->buffer_heap = NULL;
+}
+
 static BOOL buffer_process_converted_attribute(struct wined3d_buffer *buffer,
@@ -635,2 +683,13 @@ static BOOL wined3d_buffer_prepare_location(struct wined3d_buffer *buffer,
 
+        case WINED3D_LOCATION_PERSISTENT_MAP:
+            if (buffer->buffer_heap)
+                return TRUE;
+
+            if (!(buffer->flags & WINED3D_BUFFER_PERSISTENT))
+            {
+                WARN("Trying to map a persistent region for buffer %p without WINED3D_BUFFER_PERSISTENT.\n", buffer);
+                return FALSE;
+            }
+            return buffer_alloc_persistent_map(buffer, context);
+
         default:
@@ -693,2 +752,12 @@ BOOL wined3d_buffer_load_location(struct wined3d_buffer *buffer,
 
+        case WINED3D_LOCATION_PERSISTENT_MAP:
+            // TODO(acomminos): are we guaranteed location_sysmem to be kept?
+            // no.
+            if (buffer->conversion_map)
+                FIXME("Attempting to use conversion map with persistent mapping.\n");
+            memcpy(buffer->buffer_heap->map_ptr +
+                   buffer->cs_persistent_map.offset,
+                   buffer->resource.heap_memory, buffer->resource.size);
+            break;
+
         default:
@@ -699,3 +768,4 @@ BOOL wined3d_buffer_load_location(struct wined3d_buffer *buffer,
     wined3d_buffer_validate_location(buffer, location);
-    if (buffer->resource.heap_memory && location == WINED3D_LOCATION_BUFFER
+    if (buffer->resource.heap_memory
+            && location & WINED3D_LOCATION_BUFFER
             && !(buffer->resource.usage & WINED3DUSAGE_DYNAMIC))
@@ -703,2 +773,7 @@ BOOL wined3d_buffer_load_location(struct wined3d_buffer *buffer,
 
+    // FIXME(acomminos)
+    if (buffer->resource.heap_memory
+           && location & WINED3D_LOCATION_PERSISTENT_MAP)
+        wined3d_buffer_evict_sysmem(buffer);
+
     return TRUE;
@@ -724,4 +799,16 @@ DWORD wined3d_buffer_get_memory(struct wined3d_buffer *buffer,
         data->addr = NULL;
+        data->length = buffer->resource.size;
         return WINED3D_LOCATION_BUFFER;
     }
+    if (locations & WINED3D_LOCATION_PERSISTENT_MAP)
+    {
+        // FIXME(acomminos): should we expose a buffer object we don't wholly own here?
+        data->buffer_object = buffer->buffer_heap->buffer_object;
+        data->addr = buffer->cs_persistent_map.offset;
+        // Note that the size of the underlying buffer allocation may be larger
+        // than the buffer knows about. In this case, we've rounded it up to be
+        // aligned (e.g. for uniform buffer offsets).
+        data->length = buffer->cs_persistent_map.size;
+        return WINED3D_LOCATION_PERSISTENT_MAP;
+    }
     if (locations & WINED3D_LOCATION_SYSMEM)
@@ -730,2 +817,3 @@ DWORD wined3d_buffer_get_memory(struct wined3d_buffer *buffer,
         data->addr = buffer->resource.heap_memory;
+        data->length = buffer->resource.size;
         return WINED3D_LOCATION_SYSMEM;
@@ -765,2 +853,4 @@ static void buffer_unload(struct wined3d_resource *resource)
 
+    buffer_free_persistent_map(buffer);
+
     resource_unload(resource);
@@ -788,2 +878,6 @@ static void wined3d_buffer_gl_destroy_object(void *object)
 
+    struct wined3d_buffer *buffer;
+    buffer = &buffer_gl->b;
+    buffer_free_persistent_map(buffer);
+
     heap_free(buffer_gl->b.maps);
@@ -907,2 +999,12 @@ void wined3d_buffer_load(struct wined3d_buffer *buffer, struct wined3d_context *
 
+    if (buffer->flags & WINED3D_BUFFER_PERSISTENT)
+    {
+        if (wined3d_buffer_load_location(buffer, context, WINED3D_LOCATION_PERSISTENT_MAP))
+            return;
+
+        ERR("Failed to preload persistent mapping for %p, falling back to BO.\n", buffer);
+        buffer->flags |= WINED3D_BUFFER_USE_BO;
+        buffer->flags &= ~WINED3D_BUFFER_PERSISTENT;
+    }
+
     /* TODO: Make converting independent from VBOs */
@@ -1018,2 +1120,21 @@ static HRESULT wined3d_buffer_gl_map(struct wined3d_buffer_gl *buffer_gl,
 
+    if (buffer_gl->b.locations & WINED3D_LOCATION_PERSISTENT_MAP)
+    {
+        const struct wined3d_gl_info *gl_info;
+        context = context_acquire(device, NULL, 0);
+
+        FIXME_(d3d_perf)("Fences not used for persistent buffer maps on CS thread, using glFinish.\n");
+
+        gl_info = context->gl_info;
+        gl_info->gl_ops.gl.p_glFinish();
+
+        base = buffer_gl->b.buffer_heap->map_ptr
+             + buffer_gl->b.cs_persistent_map.offset;
+        *data = base + offset;
+
+        context_release(context);
+
+        return WINED3D_OK;
+    }
+
     if (buffer_gl->buffer_object)
@@ -1160,2 +1281,8 @@ static void wined3d_buffer_gl_unmap(struct wined3d_buffer_gl *buffer_gl)
 
+    if (buffer_gl->b.flags & WINED3D_BUFFER_PERSISTENT)
+    {
+        TRACE("Persistent buffer, ignore unmap.\n");
+        return;
+    }
+
     if (buffer_gl->b.map_ptr)
@@ -1284,2 +1411,61 @@ static HRESULT buffer_resource_sub_resource_map(struct wined3d_resource *resourc
         struct wined3d_map_desc *map_desc, const struct wined3d_box *box, DWORD flags)
+{
+    struct wined3d_buffer_gl *buffer_gl = wined3d_buffer_gl(buffer_from_resource(resource));
+    struct wined3d_buffer *buffer = &(buffer_gl->b);
+    UINT offset = box ? box->left : 0;
+
+    if (sub_resource_idx)
+    {
+        WARN("Invalid sub_resource_idx %u.\n", sub_resource_idx);
+        return E_INVALIDARG;
+    }
+
+    // Support immediate mapping of persistent buffers off the command thread,
+    // which require no GL calls to interface with.
+    if (buffer->locations & WINED3D_LOCATION_PERSISTENT_MAP)
+    {
+        map_desc->row_pitch = map_desc->slice_pitch = resource->size;
+        if (flags & WINED3D_MAP_DISCARD)
+        {
+            HRESULT hr;
+            struct wined3d_map_range map_range;
+            if (FAILED(hr = wined3d_buffer_heap_alloc(buffer->buffer_heap, resource->size, &map_range)))
+            {
+                FIXME_(d3d_perf)("Failed to allocate new buffer, falling back to sync path.\n");
+                return hr;
+            }
+            map_desc->data = buffer->buffer_heap->map_ptr + map_range.offset + offset;
+            resource->map_count++;
+
+            buffer->mt_persistent_map = map_range;
+
+            // Discard handler on CSMT thread is responsible for returning the
+            // currently used buffer to the free pool, along with the fence that
+            // must be called before the buffer can be reused.
+            wined3d_cs_emit_discard_buffer(resource->device->cs, buffer, map_range);
+            return WINED3D_OK;
+        }
+        else if (flags & WINED3D_MAP_NOOVERWRITE)
+        {
+            // Allow immediate access for persistent buffers without a fence.
+            // Always use the latest buffer in this case in case the latest
+            // DISCARDed one hasn't reached the command stream yet.
+            struct wined3d_map_range map_range = buffer->mt_persistent_map;
+            map_desc->data = buffer->buffer_heap->map_ptr + map_range.offset + offset;
+            resource->map_count++;
+            return WINED3D_OK;
+        }
+        else
+        {
+            // TODO(acomminos): Should check mapped ranges to see if the region is writeable even though NOOVERWRITE is specified.
+            WARN_(d3d_perf)("Mapping persistent buffer %p in sync with CS thread.\n", buffer);
+            // XXX(acomminos): kill this early return. they're the worst.
+        }
+    }
+
+    return E_NOTIMPL;
+}
+
+static HRESULT buffer_resource_sub_resource_map_cs(struct wined3d_resource *resource, unsigned int sub_resource_idx,
+        struct wined3d_map_desc *map_desc, const struct wined3d_box *box, DWORD flags)
 {
@@ -1309,2 +1494,14 @@ static HRESULT buffer_resource_sub_resource_map(struct wined3d_resource *resourc
 static HRESULT buffer_resource_sub_resource_unmap(struct wined3d_resource *resource, unsigned int sub_resource_idx)
+{
+    struct wined3d_buffer *buffer = buffer_from_resource(resource);
+    if (buffer->locations & WINED3D_LOCATION_PERSISTENT_MAP)
+    {
+        // Nothing to be done to unmap a region of a persistent buffer.
+        resource->map_count--;
+        return WINED3D_OK;
+    }
+    return E_NOTIMPL;
+}
+
+static HRESULT buffer_resource_sub_resource_unmap_cs(struct wined3d_resource *resource, unsigned int sub_resource_idx)
 {
@@ -1328,2 +1525,4 @@ static const struct wined3d_resource_ops buffer_resource_ops =
     buffer_resource_sub_resource_unmap,
+    buffer_resource_sub_resource_map_cs,
+    buffer_resource_sub_resource_unmap_cs,
 };
@@ -1406,2 +1605,16 @@ static HRESULT wined3d_buffer_init(struct wined3d_buffer *buffer, struct wined3d
 
+    if (buffer->resource.usage & WINED3DUSAGE_DYNAMIC)
+    {
+        if (!gl_info->supported[ARB_BUFFER_STORAGE])
+        {
+            WARN_(d3d_perf)("Not creating a persistent mapping for a dynamic buffer because ARB_buffer_storage is unsupported.\n");
+        }
+        else
+        {
+            // If supported, use persistent mapped buffers instead of a
+            // standalone BO for dynamic buffers.
+            buffer->flags |= WINED3D_BUFFER_PERSISTENT;
+        }
+    }
+
     /* Observations show that draw_primitive_immediate_mode() is faster on
@@ -1411,3 +1624,7 @@ static HRESULT wined3d_buffer_init(struct wined3d_buffer *buffer, struct wined3d
 
-    if (!gl_info->supported[ARB_VERTEX_BUFFER_OBJECT])
+    if (buffer->flags & WINED3D_BUFFER_PERSISTENT)
+    {
+        TRACE("Not creating a BO because a persistent mapped buffer will be used.\n");
+    }
+    else if (!gl_info->supported[ARB_VERTEX_BUFFER_OBJECT])
     {
diff --git a/dlls/wined3d/context.c b/dlls/wined3d/context.c
index 9027e94ed09..27f173b4e10 100644
--- a/dlls/wined3d/context.c
+++ b/dlls/wined3d/context.c
@@ -4905,3 +4905,7 @@ void draw_primitive(struct wined3d_device *device, const struct wined3d_state *s
         struct wined3d_buffer *index_buffer = state->index_buffer;
-        if (!wined3d_buffer_gl(index_buffer)->buffer_object || !stream_info->all_vbo)
+        if (index_buffer->locations & WINED3D_LOCATION_PERSISTENT_MAP)
+        {
+            idx_data = index_buffer->cs_persistent_map.offset;
+        }
+        else if (!wined3d_buffer_gl(index_buffer)->buffer_object || !stream_info->all_vbo)
         {
diff --git a/dlls/wined3d/cs.c b/dlls/wined3d/cs.c
index ac9adb03fa9..0f5dd607c95 100644
--- a/dlls/wined3d/cs.c
+++ b/dlls/wined3d/cs.c
@@ -75,2 +75,3 @@ enum wined3d_cs_op
     WINED3D_CS_OP_GENERATE_MIPMAPS,
+    WINED3D_CS_OP_DISCARD_BUFFER,
     WINED3D_CS_OP_STOP,
@@ -441,2 +442,9 @@ struct wined3d_cs_generate_mipmaps
 
+struct wined3d_cs_discard_buffer
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+    struct wined3d_map_range map_range;
+};
+
 struct wined3d_cs_stop
@@ -2105,3 +2113,3 @@ static void wined3d_cs_exec_map(struct wined3d_cs *cs, const void *data)
 
-    *op->hr = resource->resource_ops->resource_sub_resource_map(resource,
+    *op->hr = resource->resource_ops->resource_sub_resource_map_cs(resource,
             op->sub_resource_idx, op->map_desc, op->box, op->flags);
@@ -2139,3 +2147,3 @@ static void wined3d_cs_exec_unmap(struct wined3d_cs *cs, const void *data)
 
-    *op->hr = resource->resource_ops->resource_sub_resource_unmap(resource, op->sub_resource_idx);
+    *op->hr = resource->resource_ops->resource_sub_resource_unmap_cs(resource, op->sub_resource_idx);
 }
@@ -2489,2 +2497,49 @@ void wined3d_cs_emit_generate_mipmaps(struct wined3d_cs *cs, struct wined3d_shad
 
+static void wined3d_cs_exec_discard_buffer(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_discard_buffer *op = data;
+    struct wined3d_buffer *buffer = op->buffer;
+    HRESULT hr;
+
+    // TODO(acomminos): should call into buffer.c here instead.
+    if (FAILED(hr = wined3d_buffer_heap_free_fenced(buffer->buffer_heap, cs->device, buffer->cs_persistent_map)))
+    {
+        ERR("Failed to do a fenced free on discarded buffer %p, hr %x\n. Freeing anyway.", buffer, hr);
+        wined3d_buffer_heap_free(buffer->buffer_heap, buffer->cs_persistent_map);
+    }
+
+    buffer->cs_persistent_map = op->map_range;
+
+    // TODO(acomminos): merge this logic with buffer.c functions for standalone BOs
+    if (buffer->resource.bind_flags & WINED3D_BIND_VERTEX_BUFFER)
+        device_invalidate_state(cs->device, STATE_STREAMSRC);
+    if (buffer->resource.bind_flags & WINED3D_BIND_INDEX_BUFFER)
+        device_invalidate_state(cs->device, STATE_INDEXBUFFER);
+    if (buffer->resource.bind_flags & WINED3D_BIND_CONSTANT_BUFFER)
+    {
+        device_invalidate_state(cs->device, STATE_CONSTANT_BUFFER(WINED3D_SHADER_TYPE_VERTEX));
+        device_invalidate_state(cs->device, STATE_CONSTANT_BUFFER(WINED3D_SHADER_TYPE_HULL));
+        device_invalidate_state(cs->device, STATE_CONSTANT_BUFFER(WINED3D_SHADER_TYPE_DOMAIN));
+        device_invalidate_state(cs->device, STATE_CONSTANT_BUFFER(WINED3D_SHADER_TYPE_GEOMETRY));
+        device_invalidate_state(cs->device, STATE_CONSTANT_BUFFER(WINED3D_SHADER_TYPE_PIXEL));
+        device_invalidate_state(cs->device, STATE_CONSTANT_BUFFER(WINED3D_SHADER_TYPE_COMPUTE));
+    }
+
+    wined3d_resource_release(&op->buffer->resource);
+}
+
+void wined3d_cs_emit_discard_buffer(struct wined3d_cs *cs, struct wined3d_buffer *buffer, struct wined3d_map_range map_range)
+{
+    struct wined3d_cs_discard_buffer *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op), WINED3D_CS_QUEUE_DEFAULT);
+    op->opcode = WINED3D_CS_OP_DISCARD_BUFFER;
+    op->buffer = buffer;
+    op->map_range = map_range;
+
+    wined3d_resource_acquire(&buffer->resource);
+
+    cs->ops->submit(cs, WINED3D_CS_QUEUE_DEFAULT);
+}
+
 static void wined3d_cs_emit_stop(struct wined3d_cs *cs)
@@ -2549,2 +2604,3 @@ static void (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void
     /* WINED3D_CS_OP_GENERATE_MIPMAPS            */ wined3d_cs_exec_generate_mipmaps,
+    /* WINED3D_CS_OP_DISCARD_BUFFER              */ wined3d_cs_exec_discard_buffer,
 };
diff --git a/dlls/wined3d/resource.c b/dlls/wined3d/resource.c
index 9df0a0923b2..528c5c19ceb 100644
--- a/dlls/wined3d/resource.c
+++ b/dlls/wined3d/resource.c
@@ -335,2 +335,3 @@ HRESULT CDECL wined3d_resource_map(struct wined3d_resource *resource, unsigned i
 {
+    HRESULT hr;
     TRACE("resource %p, sub_resource_idx %u, map_desc %p, box %s, flags %#x.\n",
@@ -357,5 +358,10 @@ HRESULT CDECL wined3d_resource_map(struct wined3d_resource *resource, unsigned i
     flags = wined3d_resource_sanitise_map_flags(resource, flags);
-    wined3d_resource_wait_idle(resource);
+    if (FAILED(hr = resource->resource_ops->resource_sub_resource_map(resource, sub_resource_idx, map_desc, box, flags)))
+    {
+        TRACE_(d3d_perf)("Mapping resource %p on the command stream.\n", resource);
+        wined3d_resource_wait_idle(resource);
+        hr = wined3d_cs_map(resource->device->cs, resource, sub_resource_idx, map_desc, box, flags);
+    }
 
-    return wined3d_cs_map(resource->device->cs, resource, sub_resource_idx, map_desc, box, flags);
+    return hr;
 }
@@ -364,5 +370,11 @@ HRESULT CDECL wined3d_resource_unmap(struct wined3d_resource *resource, unsigned
 {
+    HRESULT hr;
     TRACE("resource %p, sub_resource_idx %u.\n", resource, sub_resource_idx);
 
-    return wined3d_cs_unmap(resource->device->cs, resource, sub_resource_idx);
+    if (FAILED(hr = resource->resource_ops->resource_sub_resource_unmap(resource, sub_resource_idx)))
+    {
+        TRACE_(d3d_perf)("Unmapping resource %p on the command stream.\n", resource);
+        hr = wined3d_cs_unmap(resource->device->cs, resource, sub_resource_idx);
+    }
+    return hr;
 }
diff --git a/dlls/wined3d/state.c b/dlls/wined3d/state.c
index ab67c578901..3d2608d96f3 100644
--- a/dlls/wined3d/state.c
+++ b/dlls/wined3d/state.c
@@ -4325,3 +4325,7 @@ static void indexbuffer(struct wined3d_context *context, const struct wined3d_st
         struct wined3d_buffer_gl *ib = wined3d_buffer_gl(state->index_buffer);
-        GL_EXTCALL(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ib->buffer_object));
+        // FIXME(acomminos): disasterous.
+        if (ib->b.locations & WINED3D_LOCATION_PERSISTENT_MAP)
+            GL_EXTCALL(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ib->b.buffer_heap->buffer_object));
+        else
+            GL_EXTCALL(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ib->buffer_object));
     }
@@ -4413,2 +4417,3 @@ static void state_cb(struct wined3d_context *context, const struct wined3d_state
     unsigned int i, base, count;
+    struct wined3d_bo_address bo_addr;
 
@@ -4425,4 +4430,11 @@ static void state_cb(struct wined3d_context *context, const struct wined3d_state
         buffer = state->cb[shader_type][i];
-        GL_EXTCALL(glBindBufferBase(GL_UNIFORM_BUFFER, base + i,
-                buffer ? wined3d_buffer_gl(buffer)->buffer_object : 0));
+        if (buffer)
+        {
+            wined3d_buffer_get_memory(buffer, &bo_addr, buffer->locations);
+            GL_EXTCALL(glBindBufferRange(GL_UNIFORM_BUFFER, base + i, bo_addr.buffer_object, bo_addr.addr, bo_addr.length));
+        }
+        else
+        {
+            GL_EXTCALL(glBindBufferBase(GL_UNIFORM_BUFFER, base + i, 0));
+        }
     }
diff --git a/dlls/wined3d/texture.c b/dlls/wined3d/texture.c
index 42bae136a53..24f29ecfe83 100644
--- a/dlls/wined3d/texture.c
+++ b/dlls/wined3d/texture.c
@@ -2569,2 +2569,8 @@ static HRESULT texture_resource_sub_resource_map(struct wined3d_resource *resour
         struct wined3d_map_desc *map_desc, const struct wined3d_box *box, DWORD flags)
+{
+    return E_NOTIMPL;
+}
+
+static HRESULT texture_resource_sub_resource_map_cs(struct wined3d_resource *resource, unsigned int sub_resource_idx,
+        struct wined3d_map_desc *map_desc, const struct wined3d_box *box, DWORD flags)
 {
@@ -2699,2 +2705,7 @@ static HRESULT texture_resource_sub_resource_map(struct wined3d_resource *resour
 static HRESULT texture_resource_sub_resource_unmap(struct wined3d_resource *resource, unsigned int sub_resource_idx)
+{
+    return E_NOTIMPL;
+}
+
+static HRESULT texture_resource_sub_resource_unmap_cs(struct wined3d_resource *resource, unsigned int sub_resource_idx)
 {
@@ -2750,2 +2761,4 @@ static const struct wined3d_resource_ops texture_resource_ops =
     texture_resource_sub_resource_unmap,
+    texture_resource_sub_resource_map_cs,
+    texture_resource_sub_resource_unmap_cs,
 };
diff --git a/dlls/wined3d/utils.c b/dlls/wined3d/utils.c
index 6e60c5ae3db..257719570f4 100644
--- a/dlls/wined3d/utils.c
+++ b/dlls/wined3d/utils.c
@@ -6366,2 +6366,3 @@ const char *wined3d_debug_location(DWORD location)
     LOCATION_TO_STR(WINED3D_LOCATION_RB_RESOLVED);
+    LOCATION_TO_STR(WINED3D_LOCATION_PERSISTENT_MAP);
 #undef LOCATION_TO_STR
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
index a88a2345619..2cf735e1486 100644
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -1465,2 +1465,3 @@ struct wined3d_bo_address
     BYTE *addr;
+    GLsizeiptr length;
 };
@@ -3104,2 +3105,5 @@ struct wined3d_resource_ops
     HRESULT (*resource_sub_resource_unmap)(struct wined3d_resource *resource, unsigned int sub_resource_idx);
+    HRESULT (*resource_sub_resource_map_cs)(struct wined3d_resource *resource, unsigned int sub_resource_idx,
+            struct wined3d_map_desc *map_desc, const struct wined3d_box *box, DWORD flags);
+    HRESULT (*resource_sub_resource_unmap_cs)(struct wined3d_resource *resource, unsigned int sub_resource_idx);
 };
@@ -3438,2 +3442,3 @@ void wined3d_texture_gl_set_compatible_renderbuffer(struct wined3d_texture_gl *t
 #define WINED3D_LOCATION_RB_RESOLVED    0x00000100
+#define WINED3D_LOCATION_PERSISTENT_MAP 0x00000200
 
@@ -3740,2 +3745,3 @@ void wined3d_cs_emit_update_sub_resource(struct wined3d_cs *cs, struct wined3d_r
         unsigned int slice_pitch) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_discard_buffer(struct wined3d_cs *cs, struct wined3d_buffer *buffer, struct wined3d_map_range map_range) DECLSPEC_HIDDEN;
 void wined3d_cs_init_object(struct wined3d_cs *cs,
@@ -3849,2 +3855,7 @@ struct wined3d_buffer
     UINT conversion_stride;                                 /* 0 if no shifted conversion */
+
+    /* persistent mapped buffer */
+    struct wined3d_buffer_heap *buffer_heap;
+    struct wined3d_map_range cs_persistent_map;
+    struct wined3d_map_range mt_persistent_map; // TODO: make struct list?
 };
-- 
2.19.1

